<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Auth Debug - Wander / JSON firmado (SECURE)</title>
</head>
<body>
  <h2>ðŸ§© AutenticaciÃ³n Debug (Modo Seguro)</h2>
  <h3>MÃ©todo 1: Conectar con Wander</h3>
  <button id="connectBtn">Conectar con Wander</button>
  <h3>MÃ©todo 2: Archivo firmado manualmente</h3>
  <button id="generateBtn">Generar firmar.json</button>
  <input type="file" id="fileInput" accept=".json" />
  <pre id="output"></pre>
  <script>
    // Estado de sesiÃ³n
    let sessionNonce = null;
    let sessionTimestamp = null;
    
    const out = (msg, data) => {
      const pre = document.getElementById("output");
      const timestamp = new Date().toISOString();
      pre.textContent += `\n[${timestamp}] ${msg}` + (data ? "\n" + JSON.stringify(data, null, 2) : "");
    };
    
    const connectBtn = document.getElementById("connectBtn");
    const generateBtn = document.getElementById("generateBtn");
    const fileInput = document.getElementById("fileInput");
    
    // === MÃ‰TODO 1: Conectar con Wander ===
    connectBtn.onclick = async () => {
      out("ðŸ” DEBUG: Verificando extensiÃ³n Wander...");
      if (!window.arweaveWallet) {
        out("âŒ SEGURIDAD: ExtensiÃ³n Wander no detectada");
        alert("Instala la extensiÃ³n Wander primero.");
        return;
      }
      try {
        out("ðŸ” DEBUG: Solicitando permisos...");
        await window.arweaveWallet.connect(["ACCESS_ADDRESS", "SIGN_TRANSACTION"]);
        const address = await window.arweaveWallet.getActiveAddress();
        out("âœ… SEGURIDAD: ConexiÃ³n autenticada", { address });
      } catch (e) {
        out("âŒ ERROR:", { error: e.message, stack: e.stack });
      }
    };
    
    // === MÃ‰TODO 2: AutenticaciÃ³n manual ===
    generateBtn.onclick = () => {
      out("ðŸ” DEBUG: Generando nonce de sesiÃ³n...");
      
      // Generar nonce criptogrÃ¡ficamente seguro
      const nonceArray = new Uint8Array(32);
      crypto.getRandomValues(nonceArray);
      sessionNonce = Array.from(nonceArray, b => b.toString(16).padStart(2, '0')).join('');
      sessionTimestamp = Date.now();
      
      out("âœ… SEGURIDAD: Nonce generado", { 
        nonce: sessionNonce.substring(0, 16) + "...",
        timestamp: sessionTimestamp 
      });
      
      const payload = `login-request-${sessionTimestamp}-${sessionNonce}`;
      
      const tx = {
        format: 2,
        owner: "",
        target: "",
        quantity: "0",
        data: btoa(payload),
        reward: "0",
        last_tx: "",
        tags: [
          { name: "App-Name", value: "ManualLogin" },
          { name: "Content-Type", value: "text/plain" },
          { name: "Nonce", value: sessionNonce },
          { name: "Timestamp", value: sessionTimestamp.toString() }
        ],
      };
      
      out("ðŸ“‹ DEBUG: Estructura de transacciÃ³n", {
        dataDecoded: payload,
        tagsCount: tx.tags.length
      });
      
      const blob = new Blob([JSON.stringify(tx, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "firmar.json";
      a.click();
      out("ðŸ“„ Archivo generado: firmar.json");
    };
    
    // Cargar archivo firmado con validaciones de seguridad
    fileInput.onchange = async (e) => {
      out("\nðŸ” DEBUG: Procesando archivo subido...");
      const file = e.target.files[0];
      if (!file) return;
      
      // ValidaciÃ³n 1: TamaÃ±o de archivo
      out(`ðŸ“Š DEBUG: TamaÃ±o del archivo: ${file.size} bytes`);
      if (file.size > 1024 * 1024) { // 1MB max
        out("âŒ SEGURIDAD: Archivo demasiado grande (max 1MB)");
        return;
      }
      
      // ValidaciÃ³n 2: Tipo de archivo
      if (file.type && file.type !== "application/json") {
        out("âš ï¸ ADVERTENCIA: Tipo MIME inesperado", { type: file.type });
      }
      
      const text = await file.text();
      
      try {
        out("ðŸ” DEBUG: Parseando JSON...");
        const tx = JSON.parse(text);
        
        // ValidaciÃ³n 3: Estructura bÃ¡sica
        out("ðŸ” DEBUG: Validando estructura...");
        const requiredFields = ['format', 'owner', 'data', 'tags', 'signature', 'id'];
        const missingFields = requiredFields.filter(f => !(f in tx));
        
        if (missingFields.length > 0) {
          out("âŒ SEGURIDAD: Campos faltantes", { missing: missingFields });
          return;
        }
        
        out("âœ… DEBUG: Estructura bÃ¡sica vÃ¡lida");
        
        // ValidaciÃ³n 4: Formato de transacciÃ³n
        if (tx.format !== 2) {
          out("âŒ SEGURIDAD: Formato de transacciÃ³n invÃ¡lido", { format: tx.format });
          return;
        }
        
        // ValidaciÃ³n 5: Verificar nonce de sesiÃ³n
        const txNonce = tx.tags?.find(t => t.name === "Nonce")?.value;
        const txTimestamp = tx.tags?.find(t => t.name === "Timestamp")?.value;
        
        out("ðŸ” DEBUG: Verificando nonce...", { 
          sessionNonce: sessionNonce?.substring(0, 16) + "...",
          txNonce: txNonce?.substring(0, 16) + "..." 
        });
        
        if (!sessionNonce) {
          out("âš ï¸ ADVERTENCIA: No hay sesiÃ³n activa - genera firmar.json primero");
        } else if (txNonce !== sessionNonce) {
          out("âŒ SEGURIDAD: Nonce no coincide - posible replay attack", {
            expected: sessionNonce.substring(0, 16) + "...",
            received: txNonce?.substring(0, 16) + "..."
          });
          return;
        } else {
          out("âœ… SEGURIDAD: Nonce verificado correctamente");
        }
        
        // ValidaciÃ³n 6: Verificar timestamp (no mÃ¡s de 10 minutos)
        if (sessionTimestamp && txTimestamp) {
          const age = Date.now() - parseInt(txTimestamp);
          const ageMinutes = Math.floor(age / 60000);
          out(`ðŸ• DEBUG: Edad de la transacciÃ³n: ${ageMinutes} minutos`);
          
          if (age > 600000) { // 10 minutos
            out("âŒ SEGURIDAD: TransacciÃ³n expirada (>10 min)");
            return;
          }
        }
        
        // ValidaciÃ³n 7: Verificar data coincide con nonce
        const dataDecoded = atob(tx.data);
        out("ðŸ” DEBUG: Payload decodificado", { payload: dataDecoded });
        
        if (sessionNonce && !dataDecoded.includes(sessionNonce)) {
          out("âŒ SEGURIDAD: Data no contiene el nonce esperado");
          return;
        }
        
        // ValidaciÃ³n 8: Longitud de firma y owner (Base64URL)
        const base64UrlRegex = /^[A-Za-z0-9_-]+$/;
        if (!base64UrlRegex.test(tx.signature)) {
          out("âŒ SEGURIDAD: Formato de firma invÃ¡lido");
          return;
        }
        if (!base64UrlRegex.test(tx.owner)) {
          out("âŒ SEGURIDAD: Formato de owner invÃ¡lido");
          return;
        }
        
        out("ðŸ“‚ Archivo firmado cargado y validado", {
          id: tx.id,
          signatureLength: tx.signature.length,
          ownerLength: tx.owner.length
        });
        
        // Verificar firma criptogrÃ¡fica
        out("ðŸ” DEBUG: Verificando firma criptogrÃ¡fica...");
        const valid = await verifySignature(tx);
        
        if (valid) {
          const signer = await ownerToAddress(tx.owner);
          out("âœ… SEGURIDAD: Firma criptogrÃ¡fica VÃLIDA", { signer });
          
          // Limpiar sesiÃ³n despuÃ©s de uso exitoso
          sessionNonce = null;
          sessionTimestamp = null;
          out("ðŸ§¹ DEBUG: SesiÃ³n limpiada");
          
        } else {
          out("âŒ SEGURIDAD: Firma criptogrÃ¡fica INVÃLIDA - transacciÃ³n rechazada");
        }
        
      } catch (err) {
        out("âŒ ERROR al procesar archivo", { 
          error: err.message,
          stack: err.stack,
          name: err.name
        });
      }
    };
    
    // === Utils ===
    async function verifySignature(tx) {
      try {
        await ensureArweaveLoaded();
        const arweave = window.Arweave.init({
          host: 'arweave.net',
          port: 443,
          protocol: 'https'
        });
        
        // Crear objeto Transaction desde JSON
        const transaction = new arweave.transactions.Transaction(tx);
        const result = await arweave.transactions.verify(transaction);
        
        out("ðŸ” DEBUG: Resultado de verificaciÃ³n criptogrÃ¡fica", { valid: result });
        return result;
      } catch (err) {
        out("âŒ ERROR en verificaciÃ³n", { error: err.message, stack: err.stack });
        return false;
      }
    }
    
    async function ownerToAddress(owner) {
      await ensureArweaveLoaded();
      const arweave = window.Arweave.init({
        host: 'arweave.net',
        port: 443,
        protocol: 'https'
      });
      return await arweave.wallets.ownerToAddress(owner);
    }
    
    async function ensureArweaveLoaded() {
      if (!window.Arweave) {
        out("ðŸ“¦ DEBUG: Cargando librerÃ­a Arweave...");
        const script = document.createElement("script");
        script.src = "https://unpkg.com/arweave@1.14.4/bundles/web.bundle.min.js";
        script.integrity = "sha384-x9OXX6x0kZvR6x0A8xZGQqkH7rKJq3cDN4gCmcHVW7xQ0T8zXHcXJCKxQcZvXBXb";
        script.crossOrigin = "anonymous";
        document.body.appendChild(script);
        await new Promise((resolve, reject) => {
          script.onload = resolve;
          script.onerror = () => reject(new Error("Failed to load Arweave library"));
        });
        out("âœ… DEBUG: LibrerÃ­a Arweave cargada");
      }
    }
    
    out("ðŸš€ Sistema iniciado - Modo debug seguro activado");
  </script>
</body>
</html>
